## Описание реализации клиент-серверной логики обмена и хранения данных.


### Протокол взаимодействия.

Так как требуется постоянное обновление информации на стороне сервера и минимальная задержка, думаю, что протокол WebSocket будет правильным выбором: он поддерживает постоянное соединение между сервером и клиентом, а также является двунаправленным.


### Запрос к серверу.

Запрос клиент выполняет в случае, если необходимо:  
+ получить данные с новой страницы при скролинге;  
+ изменить\сбросить порядок сортировки и\или столбец по которому происходит сортировка.  


Запрос отправляется в виде JSON в текстовых фреймах, по одному запросу на фрейм:  

```
{
    "page": "0", 
    "column_sorting": "-1",
    "sort_order": "ASC"/"DESC"/"None",
}
```
page - номер страницы;  
column_sorting - номер колонки по которой необходимо отсортировать данные. В случае, если используется сортировка по умолчанию значение "-1";  
sort_order - порядок сортировки по выбранному столбцу. Указывается в случае, если column_sorting != "-1".  


### Ответ сервера.

Ответ возвращается в виде JSON в текстовых фреймах, по одному ответу на фрейм:

```
{
    "labels": ["label_0", "label_1" ... "label_m"],
    "rows": {
        "id_0": ["val_0", "val_1" ... "val_m"],
        "id_1": ["val_0", "val_1" ... "val_m"],
        ...
        "id_n": ["val_0", "val_1" ... "val_m"]
    }
    "page": "0",
    "total_rows": "1000000"
}
```
labels - заголовки столбцов;  
rows - содержит данные по строкам: id и значения;  
page - номер страницы;  
total_rows - общее количество строк.


### Хранение данных на сервере.  

Ввиду постоянного обновления/изменения строк, данные на сервере хранятся в словаре (dict), так как BigO в среднем для CRUD операций будет равен O(1). Ключ словаря - уникальный id в необходимом формате (UUID/int). Значения словаря - список (list).


### Пагинация. 

По умолчанию клиенту отдается N первых строк с сортировкой, используемой сервером.
При скроллинге клиент отправляет серверу запрос с указанием необходимой страницы выдачи (ключ "page"). Для этого на стороне клиента оценивается смещение скрола исходя из того, что смещение при прокрутке на одно деление - M строк.  
В случае, если пользователь клиента использовал полосу прокрутки, рассчитывается смещение, исходя из положения ползунка по отношению к общей высоте зоны прокрутки. В соответсвующей пропорции рассчитывается необходимая страница, исходя из их общего числа ("total_rows" / N).


### Сортировка. 

В случае, если клиент решает отсортировать данные по определенному столбцу, то на сервер отправляется запрос с параметрами "column_sorting" и "sort_order". После чего на сервере происходит сортировка копии словаря по указанному столбцу.  
Для экономии ресурсов памяти, возможно сохранить в данном порядке только ключи, которые будут использоваться для выборки из основного набора данных при скролинге, до тех пор пока клиент не изменит порядок сортировки.

Возможный вариант сортировки и выборки ключей:
```
data = {
    1: [34, 25, 1],
    2: [2, 10, 4],
    3: [5, 12, 3],
}

data_client_sorting_ = sorted(data.items(), key=lambda item: item[1][2])
keys_client_sorting = [x[0] for x in data_client_sorting]
```
